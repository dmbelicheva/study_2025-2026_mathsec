---
## Author
author:
  name: Беличева Дарья Михайловна
  degrees: BSc
  orcid: 0009-0007-0072-0453
  email: 1032259376@pfur.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Лабораторная работа №7"
subtitle: "Дискретное логарифмирование в конечном поле"
license: "CC BY"
---


# Цель работы

Цель работы -- изучить и реализовать алгоритм Полларда для дискретного логарифмирования в конечном поле.

# Задание

С помощью языка программирования Julia:

- реализовать алгоритм Полларда для дискретного логарифмирования в конечном поле

# Теоретическое введение

Julia -- высокоуровневый свободный язык программирования с динамической типизацией, созданный для математических вычислений [@julialang]. Эффективен также и для написания программ общего назначения. Синтаксис языка схож с синтаксисом других математических языков, однако имеет некоторые существенные отличия.

Для выполнения заданий была использована официальная документация Julia [@juliadoc].


# Выполнение лабораторной работы

Реализуем алгоритм Полларда для дискретного логарифмирования в конечном поле:

```Julia
function step(c, u, v, a, b, p)
    if c < div(p, 2)
        # f(c) = a*c => log_a(f(c)) = log_a(c) + 1
        c = (a * c) % p
        u = (u + 1) % p   # x^0 части у — коэффициент перед x^0
    else
        # f(c) = b*c => log_a(f(c)) = log_a(c) + x
        c = (b * c) % p
        v = (v + 1) % p   # x^1 части v — коэффициент перед x
    end
    return c, u, v
end


function pollard_simple(a, b, p, r; u0=2, v0=2)
    # начальные состояния
    c  = powermod(a, u0, p) * powermod(b, v0, p) % p
    u  = u0
    v  = v0

    d  = c
    u2 = u
    v2 = v

    step_num = 0

    while true
        # один шаг черепахи
        c, u, v = step(c, u, v, a, b, p)

        # два шага зайца
        d, u2, v2 = step(d, u2, v2, a, b, p)
        d, u2, v2 = step(d, u2, v2, a, b, p)

        step_num += 1
        if c == d
            A = (v - v2) % r
            B = (u2 - u) % r

            if A == 0
                println("Решения нет (A = 0).")
                return nothing
            end

            x = (B * invmod(A, r)) % r
            println("Найден логарифм x = $x")
            return x
        end
    end
end


a = 10
b = 64
p = 107
r = 53

println("Решаем 10^x ≡ 64 (mod 107)")
x = pollard_simple(a, b, p, r)

println("\nПроверка: powermod(10, x, 107) = ", powermod(10, x, 107))
```

В результате получим следующие шифротексты([рис. @fig-001]).

![Результат работы программы](image/1.png){#fig-001 width=70%}

# Выводы

С помощью языка программирования Julia был реализован алгоритм Полларда для дискретного логарифмирования в конечном поле

# Список литературы{.unnumbered}

::: {#refs}
:::
